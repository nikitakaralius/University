

# Заполнение массива

## Решение
Для начала поймем суть алгоритма: дан двумерный массив N×M, который мы заполняем целыми положительными числами. В первом столбце каждой строки ставится ее порядковый номер: число от 1 до N. Затем последующие элементы строки заполняются разностью произведения номера строки и столбца с предыдущим элементом. Необходимо узнать, сколько четных элементов содержит эта матрица.

 Абстрагируемся от конкретных чисел и будем считать, что массив заполняется четными/нечетными числами. Вспомним, что четное число можно получить в следующих случаях:

* чет+чет
* нечет+нечет
* чет × (чет/нечет)

В таком случае в строках с четным номером все элементы будут четные: строка начинается с четного, произведение с четным числом дает четное число, и разность четного с четным - четное.

В строках же с нечетными номерами получим чередование: *[нечет; нечет; чет; чет; нечет; нечет; чет; чет; ...]*

Для массива размером n=20 m=19 получаем:
* 10 четных строк по 19 элементов: 10  × 19 = 190
* 10 нечетных строк по 9 четных элементов в каждой: 10 × 9 = 90
* Их сумма: 190 + 90 = 280

**Ответ: 280**

<div class="page" />

## Программное решение на F#

```F#
let generateArray n m =
    let set i j value (array: 'a [,]) = array[i - 1, j - 1] <- value
    let get i j (array: 'a [,]) = array[i - 1, j - 1]

    let array = Array2D.create n m 0

    for k in 1..n do
        array |> set k 1 k

        for j in 2..m do
            let value = k * j - (array |> get k (j - 1))
            array |> set k j value

    array

let n, m = 20, 19

generateArray n m
|> Seq.cast<int>
|> Seq.filter (fun x -> x % 2 = 0)
|> Seq.length
|> printfn "%i"
```

Так как в языке индексация начинается с 0, были добавлены две вспомогательные функции для обращения по индексам, представленным на блок схеме.

```
Input: n = 20; m = 19
Output: 280
```

**Ответ: 280**